---
title: "Hash Map 01"
categories:
  - development
  - cs
tags:
  - Backend
  - 자료구조
last_modified_at: 2025-06-04
toc: true
---

## Hash Map

Key와 Value를 한 쌍으로 저장하는 형태의 자료구조를 Map이라고 한다

Key를 해시 함수(Hash Function)를 통해 배열의 인덱스로 변환하고
해당 인덱스를 사용해서 Value를 가져오는 방식으로 구현한 Map을 Hash Map이라고 한다

Hash Map의 가장 큰 장점은 원하는 데이터에 빠르게 접근 가능하다는 점이다

기본적으로 배열에서 인덱스로 접근하는 방식이기 때문에 시간복잡도 O(1)을 가진다

### 크기

Hash Map의 크기를 어떻게 설정하는가는 중요한 고민이다

너무 작은 크기일 경우 해시 충돌이 많이 발생하고 이는 결국 데이터 접근에 빠르게 접근하다는 장점을 퇴색시킨다

반면 너무 큰 크기일 경우 실제 저장하는 데이터의 크기에 비해 자료구조의 크기가 너무 커서 데이터 공간을 낭비한다는 문제가 생긴다

그렇기 때문에 많은 Hash Map은 일정량의 데이터가 채워지면 Hash Map의 크기를 늘리는 가변 방식으로 구현된다

버킷이라고 불리는 일정한 크기를 단위로 해서 늘리고 줄이는 방식을 보편적으로 사용한다

### 해시 충돌

다른 Key가 해시 함수를 통해 같은 인덱스가 되는 현상을 해시 충돌(Hash Collision)이라고 한다

해시 충돌이 발생하면 어떤 방식으로든 Key에 따른 Value 반환이라는 자료구조 자체의 기능은 유지되야 하기 때문에
별도 작업을 필요로 한다

그러면 당연히 성능이 저하되기 때문에 해시 충돌은 최대한 피해야 한다

하지만 해시 충돌를 완전히 방지할 수는 없기 때문에 앞서 말한 별도의 작업도 반드시 필요하다

### Seperate Chaining

Value를 연결리스트 형태로 할당해서 해시 충돌이 발생하면 해당 연결리스트에 Value를 추가하는 방법

해시 충돌 시 복잡한 로직 없이 연결리스트에 추가만 하면 된다

연결리스트가 길어질수록 성능 저하가 일어난다

### Open Addressing

해시 충돌이 발생한 경우 해당 Key와 Value를 일정한 규칙에 따라 다른 위치에 삽입하는 방식

규칙은 선형 탐색, 제곱 탐색, 이중 해시 등이 있다

- 선형 탐색 : 바로 다음 혹은 일정한 간격을 두고 데이터를 삽입
- 제곱 탐색 : 제곱만큼 건너 뛰어서 데이터를 삽입
- 이중 해시 : 다른 해시 함수를 한 번 더 적용한 결과에 따라 데이터를 삽입

지정한 메모리 외에 추가 공간이 필요 없다

삽입, 삭제 오버헤드가 적다

하지만 다른 곳에 데이터를 삽입하는 방식이기 때문에 Hash Map이 차면 찰수록
연쇄적인 해시 충돌이 일어날 확률이 높아져서 성능이 크게 낮아진다
